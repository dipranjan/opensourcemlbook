
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Convolutional Neural Networks &#8212; The Open Source Machine Learning Book</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.2d2078699c18a0efb88233928e1cf6ed.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.be0a4a0c39cd630af62a2fcf693f3f06.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo.gif"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Understanding and Visualizing Convolutional Neural Networks" href="Understanding%20and%20Visualizing%20Convolutional%20Neural%20Networks.html" />
    <link rel="prev" title="Neural Networks as Universal Approximators" href="../../Neural%20Network/Neural%20Networks%20as%20Universal%20Approximators.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../../index.html">
  
  <img src="../../../_static/logo.gif" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">The Open Source Machine Learning Book</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../intro.html">
   About this Book
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Python
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../Python/Classes%20and%20Objects/Classes%20and%20Objects.html">
   Classes and Objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../Python/Linked%20Lists/Linked%20Lists.html">
   Linked Lists
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Neural Networks
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../Neural%20Network/Neural%20Networks%20as%20Universal%20Approximators.html">
   Neural Networks as Universal Approximators
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Convolutional Neural Networks
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Convolutional Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Understanding%20and%20Visualizing%20Convolutional%20Neural%20Networks.html">
   Understanding and Visualizing Convolutional Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Transfer%20Learning%20and%20Fine-tuning%20Convolutional%20Neural%20Networks.html">
   Transfer Learning and Fine-tuning Convolutional Neural Network
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Understanding%20Convolutions%20in%20Depth.html">
   Understanding Convolutions in Depth
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Reinforcement Learning
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../Reinforcement%20Learning/Finite%20Markov%20Decision%20Processes/Finite%20Markov%20Decision%20Processes.html">
   Finite Markov Decision Processes
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/contents/Deep Learning/Convolutional Neural Networks for Visual Recognition/Convolutional Neural Networks for Visual Recognition.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/dipranjan/opensourcemlbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/dipranjan/opensourcemlbook/issues/new?title=Issue%20on%20page%20%2Fcontents/Deep Learning/Convolutional Neural Networks for Visual Recognition/Convolutional Neural Networks for Visual Recognition.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/dipranjan/opensourcemlbook/edit/master/contents/Deep Learning/Convolutional Neural Networks for Visual Recognition/Convolutional Neural Networks for Visual Recognition.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#architecture-overview">
   Architecture Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#layers-used-to-build-convnets">
   Layers used to build ConvNets
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convolutional-layer">
     Convolutional Layer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pooling-layer">
     Pooling Layer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#normalization-layer">
     Normalization Layer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fully-connected-layer">
     Fully-connected layer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#converting-fc-layers-to-conv-layers">
     Converting FC layers to CONV layers
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#convnet-architectures">
   ConvNet Architectures
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#layer-patterns">
     Layer Patterns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#layer-sizing-patterns">
     Layer Sizing Patterns
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#case-studies">
   Case studies
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computational-considerations">
   Computational Considerations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-resources">
   Additional Resources
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="convolutional-neural-networks">
<h1>Convolutional Neural Networks<a class="headerlink" href="#convolutional-neural-networks" title="Permalink to this headline">¶</a></h1>
<div class="tip admonition">
<p class="admonition-title">Original Source:</p>
<p><a class="reference external" href="https://cs231n.github.io/convolutional-networks/">CS231n of Stanford</a></p>
</div>
<div class="dropdown admonition">
<p class="admonition-title">About the Authors:</p>
<p><strong>Andrej Karpathy</strong> (born October 23, 1986) is the director of artificial intelligence and Autopilot Vision at Tesla. He specializes in deep learning and image recognition and understanding.</p>
<p>Andrej Karpathy was born in Slovakia and moved with his family to Toronto when he was 15. He completed his Computer Science and Physics bachelor’s degree at University of Toronto in 2009 and completed his master’s degree at University of British Columbia in 2011, where he worked on physically-simulated figures. He graduated with PhD from Stanford University in 2015 under the supervision of <strong>Fei-Fei Li</strong>, focusing on the intersection of natural language processing and computer vision, and deep learning models suited for this task. He joined the artificial intelligence group OpenAI as a research scientist in September 2016 and became Tesla’s director of artificial intelligence in June 2017.</p>
<p>Karpathy was named one of the MIT Technology Review Innovators Under 35 for the year 2020.</p>
</div>
<p>Convolutional Neural Networks are very similar to ordinary Neural Networks, they are made up of neurons that have learnable weights and biases. Each neuron receives some inputs, performs a dot product and optionally follows it with a non-linearity. The whole network still expresses a single differentiable score function: from the raw image pixels on one end to class scores at the other. And they still have a loss function (e.g. SVM/Softmax) on the last (fully-connected) layer and all the tips/tricks we developed for learning regular Neural Networks still apply.</p>
<p>So what changes? <strong>ConvNet architectures make the explicit assumption that the inputs are images, which allows us to encode certain properties into the architecture.</strong> These then make the forward function more efficient to implement and vastly reduce the amount of parameters in the network.</p>
<div class="section" id="architecture-overview">
<h2>Architecture Overview<a class="headerlink" href="#architecture-overview" title="Permalink to this headline">¶</a></h2>
<p>Neural Networks receive an input (a single vector), and transform it through a series of hidden layers. Each hidden layer is made up of a set of neurons, where each neuron is fully connected to all neurons in the previous layer, and where neurons in a single layer function completely independently and do not share any connections. The last fully-connected layer is called the “output layer” and in classification settings it represents the class scores.</p>
<p>Regular Neural Nets don’t scale well to full images. In <a class="reference external" href="https://www.tensorflow.org/datasets/catalog/cifar10">CIFAR-10</a>, images are only of size <span class="math notranslate nohighlight">\( 32*32*3\)</span> (32 wide, 32 high, 3 color channels RGB), so a single fully-connected neuron in a first hidden layer of a regular Neural Network would have <span class="math notranslate nohighlight">\( 32*32*3 = 3072 \)</span> weights. This amount still seems manageable, but clearly this fully-connected structure does not scale to larger images. For example, an image of more respectable size, e.g. <span class="math notranslate nohighlight">\( 200*200*3\)</span>, would lead to neurons that have <span class="math notranslate nohighlight">\(200*200*3 = 120000\)</span> weights. Moreover, we would almost certainly want to have several such neurons, so the parameters would add up quickly! Clearly, this full connectivity is wasteful and the huge number of parameters would quickly lead to overfitting.</p>
<p><strong>3D volumes of neurons:</strong> Convolutional Neural Networks take advantage of the fact that the input consists of images and they constrain the architecture in a more sensible way. In particular, unlike a regular Neural Network, the layers of a ConvNet have neurons arranged in 3 dimensions: width, height, depth. (Note that the word depth here refers to the third dimension of an activation volume, not to the depth of a full Neural Network, which can refer to the total number of layers in a network.) For example, the input images in CIFAR-10 are an input volume of activations, and the volume has dimensions <span class="math notranslate nohighlight">\(32*32*3\)</span> (width, height, depth respectively). As we will soon see, the neurons in a layer will only be connected to a small region of the layer before it, instead of all of the neurons in a fully-connected manner. Moreover, the final output layer would for CIFAR-10 have dimensions <span class="math notranslate nohighlight">\(1*1*10\)</span>, because by the end of the ConvNet architecture we will reduce the full image into a single vector of class scores, arranged along the depth dimension. Here is a visualization:</p>
<div class="figure align-default" id="image1">
<a class="reference internal image-reference" href="../../../_images/image1.png"><img alt="../../../_images/image1.png" src="../../../_images/image1.png" style="height: 150px;" /></a>
<p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">Left: A regular 3-layer Neural Network. Right: A ConvNet arranges its neurons in three dimensions (width, height, depth), as visualized in one of the layers. Every layer of a ConvNet transforms the 3D input volume to a 3D output volume of neuron activations. In this example, the red input layer holds the image, so its width and height would be the dimensions of the image, and the depth would be 3 (Red, Green, Blue channels).</span><a class="headerlink" href="#image1" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A ConvNet is made up of Layers. Every Layer has a simple API: It transforms an input 3D volume to an output 3D volume with some differentiable function that may or may not have parameters.</p>
</div>
</div>
<div class="section" id="layers-used-to-build-convnets">
<h2>Layers used to build ConvNets<a class="headerlink" href="#layers-used-to-build-convnets" title="Permalink to this headline">¶</a></h2>
<p>As we described above, a simple ConvNet is a sequence of layers, and every layer of a ConvNet transforms one volume of activations to another through a differentiable function. We use three main types of layers to build ConvNet architectures: <em>Convolutional Layer, Pooling Layer and Fully-Connected Layer</em> (exactly as seen in regular Neural Networks). We will stack these layers to form a full ConvNet architecture.</p>
<p>Example Architecture: Overview. We will go into more details below, but a simple ConvNet for CIFAR-10 classification could have the architecture [INPUT - CONV - RELU - POOL - FC]. In more detail:</p>
<ul class="simple">
<li><p>INPUT <span class="math notranslate nohighlight">\([32*32*3]\)</span> will hold the raw pixel values of the image, in this case an image of width 32, height 32, and with three color channels R,G,B.</p></li>
<li><p>CONV layer will compute the output of neurons that are connected to local regions in the input, each computing a dot product between their weights and a small region they are connected to in the input volume. This may result in volume such as <span class="math notranslate nohighlight">\([32*32*12]\)</span> if we decided to use 12 filters.</p></li>
<li><p>RELU layer will apply an elementwise activation function, such as the max(0,x) thresholding at zero. This leaves the size of the volume unchanged (<span class="math notranslate nohighlight">\([32*32*12]\)</span>).</p></li>
<li><p>POOL layer will perform a downsampling operation along the spatial dimensions (width, height), resulting in volume such as <span class="math notranslate nohighlight">\([16*16*12]\)</span>.</p></li>
<li><p>FC (i.e. fully-connected) layer will compute the class scores, resulting in volume of size <span class="math notranslate nohighlight">\([1*1*10]\)</span>, where each of the 10 numbers correspond to a class score, such as among the 10 categories of CIFAR-10. As with ordinary Neural Networks and as the name implies, each neuron in this layer will be connected to all the numbers in the previous volume.</p></li>
</ul>
<p>In this way, ConvNets transform the original image layer by layer from the original pixel values to the final class scores. Note that some layers contain parameters and other don’t. In particular, the CONV/FC layers perform transformations that are a function of not only the activations in the input volume, but also of the parameters (the weights and biases of the neurons). <strong>On the other hand, the RELU/POOL layers will implement a fixed function. The parameters in the CONV/FC layers will be trained with gradient descent so that the class scores that the ConvNet computes are consistent with the labels in the training set for each image.</strong></p>
<p>In summary:</p>
<ul class="simple">
<li><p>A ConvNet architecture is in the simplest case a list of Layers that transform the image volume into an output volume (e.g. holding the class scores)</p></li>
<li><p>There are a few distinct types of Layers (e.g. CONV/FC/RELU/POOL are by far the most popular)</p></li>
<li><p>Each Layer accepts an input 3D volume and transforms it to an output 3D volume through a differentiable function</p></li>
<li><p>Each Layer may or may not have parameters (e.g. CONV/FC do, RELU/POOL don’t)</p></li>
<li><p>Each Layer may or may not have additional hyperparameters (e.g. CONV/FC/POOL do, RELU doesn’t)</p></li>
</ul>
<div class="figure align-default" id="image2">
<a class="reference internal image-reference" href="../../../_images/image2.png"><img alt="../../../_images/image2.png" src="../../../_images/image2.png" style="height: 350px;" /></a>
<p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">The activations of an example ConvNet architecture. The initial volume stores the raw image pixels (left) and the last volume stores the class scores (right). Each volume of activations along the processing path is shown as a column. Since it’s difficult to visualize 3D volumes, we lay out each volume’s slices in rows. The last layer volume holds the scores for each class, but here we only visualize the sorted top 5 scores, and print the labels of each one. The full web-based demo is shown in the header of our website. The architecture shown here is a tiny VGG Net, which we will discuss later.</span><a class="headerlink" href="#image2" title="Permalink to this image">¶</a></p>
</div>
<p>We now describe the individual layers and the details of their hyperparameters and their connectivities.</p>
<div class="section" id="convolutional-layer">
<h3>Convolutional Layer<a class="headerlink" href="#convolutional-layer" title="Permalink to this headline">¶</a></h3>
<p>The Conv layer is the core building block of a Convolutional Network that does most of the computational heavy lifting.</p>
<p><strong>Overview and intuition without brain stuff:</strong> Let’s first discuss what the CONV layer computes without brain/neuron analogies. The CONV layer’s parameters consist of a set of learnable filters. Every filter is small spatially (along width and height), but extends through the full depth of the input volume. For example, a typical filter on a first layer of a ConvNet might have size <span class="math notranslate nohighlight">\(5*5*3\)</span> (i.e. 5 pixels width and height, and 3 because images have depth 3, the color channels). During the forward pass, we slide (more precisely, convolve) each filter across the width and height of the input volume and compute dot products between the entries of the filter and the input at any position. As we slide the filter over the width and height of the input volume we will produce a 2-dimensional activation map that gives the responses of that filter at every spatial position. Intuitively, the network will learn filters that activate when they see some type of visual feature such as an edge of some orientation or a blotch of some color on the first layer, or eventually entire honeycomb or wheel-like patterns on higher layers of the network. Now, we will have an entire set of filters in each CONV layer (e.g. 12 filters), and each of them will produce a separate 2-dimensional activation map. We will stack these activation maps along the depth dimension and produce the output volume.</p>
<p><strong>The brain view:</strong> If you’re a fan of the brain/neuron analogies, every entry in the 3D output volume can also be interpreted as an output of a neuron that looks at only a small region in the input and shares parameters with all neurons to the left and right spatially (since these numbers all result from applying the same filter). We now discuss the details of the neuron connectivities, their arrangement in space, and their parameter sharing scheme.</p>
<p><strong>Local Connectivity:</strong> When dealing with high-dimensional inputs such as images, as we saw above it is impractical to connect neurons to all neurons in the previous volume. Instead, we will connect each neuron to only a local region of the input volume. The spatial extent of this connectivity is a hyperparameter called the receptive field of the neuron (equivalently this is the filter size). The extent of the connectivity along the depth axis is always equal to the depth of the input volume. It is important to emphasize again this asymmetry in how we treat the spatial dimensions (width and height) and the depth dimension: The connections are local in space (along width and height), but always full along the entire depth of the input volume.</p>
<p><em>Example 1.</em> For example, suppose that the input volume has size <span class="math notranslate nohighlight">\([32*32*3]\)</span>, (e.g. an RGB CIFAR-10 image). If the receptive field (or the filter size) is <span class="math notranslate nohighlight">\(5*5\)</span>, then each neuron in the Conv Layer will have weights to a <span class="math notranslate nohighlight">\([5*5*3]\)</span> region in the input volume, for a total of <span class="math notranslate nohighlight">\(5*5*3 = 75\)</span> weights (and +1 bias parameter). Notice that the extent of the connectivity along the depth axis must be 3, since this is the depth of the input volume.</p>
<p><em>Example 2.</em> Suppose an input volume had size <span class="math notranslate nohighlight">\([16*16*20]\)</span>. Then using an example receptive field size of <span class="math notranslate nohighlight">\(3*3\)</span>, every neuron in the Conv Layer would now have a total of <span class="math notranslate nohighlight">\(3*3*20 = 180\)</span> connections to the input volume. Notice that, again, the connectivity is local in space (e.g. <span class="math notranslate nohighlight">\(3*3\)</span>), but full along the input depth (20).</p>
<div class="figure align-default" id="image3">
<a class="reference internal image-reference" href="../../../_images/image3.png"><img alt="../../../_images/image3.png" src="../../../_images/image3.png" style="height: 250px;" /></a>
<p class="caption"><span class="caption-number">Fig. 33 </span><span class="caption-text">Left: An example input volume in red (e.g. a 32x32x3 CIFAR-10 image), and an example volume of neurons in the first Convolutional layer. Each neuron in the convolutional layer is connected only to a local region in the input volume spatially, but to the full depth (i.e. all color channels). Note, there are multiple neurons (5 in this example) along the depth, all looking at the same region in the input - see discussion of depth columns in text below. Right: The neurons from the Neural Network chapter remain unchanged: They still compute a dot product of their weights with the input followed by a non-linearity, but their connectivity is now restricted to be local spatially.</span><a class="headerlink" href="#image3" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Spatial arrangement:</strong> We have explained the connectivity of each neuron in the Conv Layer to the input volume, but we haven’t yet discussed how many neurons there are in the output volume or how they are arranged. Three hyperparameters control the size of the output volume: the depth, stride and zero-padding. We discuss these next:</p>
<ul class="simple">
<li><p>First, the depth of the output volume is a hyperparameter: it corresponds to the number of filters we would like to use, each learning to look for something different in the input. For example, if the first Convolutional Layer takes as input the raw image, then different neurons along the depth dimension may activate in presence of various oriented edges, or blobs of color. We will refer to a set of neurons that are all looking at the same region of the input as a depth column (some people also prefer the term fibre).</p></li>
<li><p>Second, we must specify the stride with which we slide the filter. When the stride is 1 then we move the filters one pixel at a time. When the stride is <span class="math notranslate nohighlight">\(2\)</span> (or uncommonly <span class="math notranslate nohighlight">\(3\)</span> or more, though this is rare in practice) then the filters jump 2 pixels at a time as we slide them around. This will produce smaller output volumes spatially.
As we will soon see, sometimes it will be convenient to pad the input volume with zeros around the border. The size of this zero-padding is a hyperparameter. The nice feature of zero padding is that it will allow us to control the spatial size of the output volumes (most commonly as we’ll see soon we will use it to exactly preserve the spatial size of the input volume so the input and output width and height are the same).</p></li>
</ul>
<p>We can compute the spatial size of the output volume as a function of the input volume size (W), the receptive field size of the Conv Layer neurons (F), the stride with which they are applied (S), and the amount of zero padding used (P) on the border. You can convince yourself that the correct formula for calculating how many neurons “fit” is given by <span class="math notranslate nohighlight">\((W−F+2P)/S+1\)</span>. For example for a <span class="math notranslate nohighlight">\(7*7\)</span> input and a <span class="math notranslate nohighlight">\(3*3\)</span> filter with stride 1 and pad 0 we would get a <span class="math notranslate nohighlight">\(5*5\)</span> output. With stride 2 we would get a <span class="math notranslate nohighlight">\(3*3\)</span> output. Lets also see one more graphical example:</p>
<div class="figure align-default" id="image4">
<a class="reference internal image-reference" href="../../../_images/image4.png"><img alt="../../../_images/image4.png" src="../../../_images/image4.png" style="height: 150px;" /></a>
<p class="caption"><span class="caption-number">Fig. 34 </span><span class="caption-text">Illustration of spatial arrangement. In this example there is only one spatial dimension (x-axis), one neuron with a receptive field size of <span class="math notranslate nohighlight">\(F = 3\)</span>, the input size is <span class="math notranslate nohighlight">\(W = 5\)</span>, and there is zero padding of <span class="math notranslate nohighlight">\(P = 1\)</span>. Left: The neuron strided across the input in stride of <span class="math notranslate nohighlight">\(S = 1\)</span>, giving output of size <span class="math notranslate nohighlight">\((5 - 3 + 2)/1+1 = 5\)</span>. Right: The neuron uses stride of <span class="math notranslate nohighlight">\(S = 2\)</span>, giving output of size <span class="math notranslate nohighlight">\((5 - 3 + 2)/2+1 = 3\)</span>. Notice that stride <span class="math notranslate nohighlight">\(S = 3\)</span> could not be used since it wouldn’t fit neatly across the volume. In terms of the equation, this can be determined since <span class="math notranslate nohighlight">\((5 - 3 + 2) = 4\)</span> is not divisible by <span class="math notranslate nohighlight">\(3\)</span>.
The neuron weights are in this example <span class="math notranslate nohighlight">\([1,0,-1]\)</span> (shown on very right), and its bias is zero. These weights are shared across all yellow neurons (see parameter sharing below).</span><a class="headerlink" href="#image4" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Use of zero-padding:</strong> In the example above on left, note that the input dimension was 5 and the output dimension was equal: also 5. This worked out so because our receptive fields were 3 and we used zero padding of 1. If there was no zero-padding used, then the output volume would have had spatial dimension of only 3, because that is how many neurons would have “fit” across the original input. In general, setting zero padding to be <span class="math notranslate nohighlight">\(P=(F−1)/2\)</span> when the stride is <span class="math notranslate nohighlight">\(S=1\)</span> ensures that the input volume and output volume will have the same size spatially. It is very common to use zero-padding in this way and we will discuss the full reasons when we talk more about ConvNet architectures.</p>
<p><strong>Constraints on strides:</strong> Note again that the spatial arrangement hyperparameters have mutual constraints. For example, when the input has size <span class="math notranslate nohighlight">\(W=10\)</span>, no zero-padding is used <span class="math notranslate nohighlight">\(P=0\)</span>, and the filter size is <span class="math notranslate nohighlight">\(F=3\)</span>, then it would be impossible to use stride <span class="math notranslate nohighlight">\(S=2\)</span>, since <span class="math notranslate nohighlight">\((W−F+2P)/S+1=(10−3+0)/2+1=4.5\)</span>, i.e. not an integer, indicating that the neurons don’t “fit” neatly and symmetrically across the input. Therefore, this setting of the hyperparameters is considered to be invalid, and a ConvNet library could throw an exception or zero pad the rest to make it fit, or crop the input to make it fit, or something. As we will see in the ConvNet architectures section, sizing the ConvNets appropriately so that all the dimensions “work out” can be a real headache, which the use of zero-padding and some design guidelines will significantly alleviate.</p>
<p><strong>Real-world example:</strong> The <a class="reference external" href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al.</a> architecture that won the ImageNet challenge in 2012 accepted images of size <span class="math notranslate nohighlight">\([227*227*3]\)</span>. On the first Convolutional Layer, it used neurons with receptive field size <span class="math notranslate nohighlight">\(F=11\)</span>, stride <span class="math notranslate nohighlight">\(S=4\)</span> and no zero padding <span class="math notranslate nohighlight">\(P=0\)</span>. Since <span class="math notranslate nohighlight">\((227 - 11)/4 + 1 = 55\)</span>, and since the Conv layer had a depth of <span class="math notranslate nohighlight">\(K=96\)</span>, the Conv layer output volume had size <span class="math notranslate nohighlight">\([55*55*96]\)</span>. Each of the <span class="math notranslate nohighlight">\(55*55*96\)</span> neurons in this volume was connected to a region of size <span class="math notranslate nohighlight">\([11*11*3]\)</span> in the input volume. Moreover, all 96 neurons in each depth column are connected to the same <span class="math notranslate nohighlight">\([11*11*3]\)</span> region of the input, but of course with different weights. As a fun aside, if you read the actual paper it claims that the input images were <span class="math notranslate nohighlight">\(224*224\)</span>, which is surely incorrect because <span class="math notranslate nohighlight">\((224 - 11)/4 + 1\)</span> is quite clearly not an integer. This has confused many people in the history of ConvNets and little is known about what happened. My own best guess is that Alex used zero-padding of 3 extra pixels that he does not mention in the paper.</p>
<div class="figure align-default" id="image5">
<a class="reference internal image-reference" href="../../../_images/image5.png"><img alt="../../../_images/image5.png" src="../../../_images/image5.png" style="height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 35 </span><span class="caption-text">In 2012, Alex Krizhevsky, Ilya Sutskever, and Geoff Hinton blew existing image classification results out of the water. Their progress was the result of combining together a bunch of different pieces. They used GPUs to train a very large, deep, neural network. They used a new kind of neuron (ReLUs) and a new technique to reduce a problem called ‘overfitting’ (DropOut). They used a very large dataset with lots of image categories (ImageNet). And, of course, it was a convolutional neural network.
Their architecture, illustrated above, was very deep. It has 5 convolutional layers, 3 with pooling interspersed, and 3 fully-connected layers. The early layers are split over the two GPUs.</span><a class="headerlink" href="#image5" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Parameter Sharing:</strong> Parameter sharing scheme is used in Convolutional Layers to control the number of parameters. Using the real-world example above, we see that there are <span class="math notranslate nohighlight">\(55*55*96 = 290400\)</span> neurons in the first Conv Layer, and each has <span class="math notranslate nohighlight">\(11*11*3 = 363\)</span> weights and <span class="math notranslate nohighlight">\(1\)</span> bias. Together, this adds up to <span class="math notranslate nohighlight">\(290400 * 364 = 105705600\)</span> parameters on the first layer of the ConvNet alone. Clearly, this number is very high.</p>
<p>It turns out that we can dramatically reduce the number of parameters by making one reasonable assumption: That if one feature is useful to compute at some spatial position <span class="math notranslate nohighlight">\((x,y)\)</span>, then it should also be useful to compute at a different position <span class="math notranslate nohighlight">\((x_2,y_2)\)</span>. In other words, denoting a single 2-dimensional slice of depth as a depth slice (e.g. a volume of size <span class="math notranslate nohighlight">\([55*55*96]\)</span> has <span class="math notranslate nohighlight">\(96\)</span> depth slices, each of size <span class="math notranslate nohighlight">\([55*55]\)</span>), we are going to constrain the neurons in each depth slice to use the same weights and bias. With this parameter sharing scheme, the first Conv Layer in our example would now have only <span class="math notranslate nohighlight">\(96\)</span> unique set of weights (one for each depth slice), for a total of <span class="math notranslate nohighlight">\(96*11*11*3 = 34848\)</span> unique weights, or <span class="math notranslate nohighlight">\(34944\)</span> parameters (<span class="math notranslate nohighlight">\(+96\)</span> biases). Alternatively, all <span class="math notranslate nohighlight">\(55*55\)</span> neurons in each depth slice will now be using the same parameters. In practice during backpropagation, every neuron in the volume will compute the gradient for its weights, but these gradients will be added up across each depth slice and only update a single set of weights per slice.</p>
<p>Notice that if all neurons in a single depth slice are using the same weight vector, then the forward pass of the CONV layer can in each depth slice be computed as a convolution of the neuron’s weights with the input volume (Hence the name: Convolutional Layer). This is why it is common to refer to the sets of weights as a filter (or a kernel), that is convolved with the input.</p>
<div class="figure align-default" id="image6">
<a class="reference internal image-reference" href="../../../_images/image6.png"><img alt="../../../_images/image6.png" src="../../../_images/image6.png" style="height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 36 </span><span class="caption-text">Example filters learned by Krizhevsky et al. Each of the 96 filters shown here is of size [11x11x3], and each one is shared by the 55x55 neurons in one depth slice. Notice that the parameter sharing assumption is relatively reasonable: If detecting a horizontal edge is important at some location in the image, it should intuitively be useful at some other location as well due to the translationally-invariant structure of images. There is therefore no need to relearn to detect a horizontal edge at every one of the 55x55 distinct locations in the Conv layer output volume.</span><a class="headerlink" href="#image6" title="Permalink to this image">¶</a></p>
</div>
<p>Note that sometimes the parameter sharing assumption may not make sense. This is especially the case when the input images to a ConvNet have some specific centered structure, where we should expect, for example, that completely different features should be learned on one side of the image than another. One practical example is when the input are faces that have been centered in the image. You might expect that different eye-specific or hair-specific features could (and should) be learned in different spatial locations. In that case it is common to relax the parameter sharing scheme, and instead simply call the layer a <strong>Locally-Connected Layer</strong>.</p>
<p><strong>Numpy examples:</strong> To make the discussion above more concrete, lets express the same ideas but in code and with a specific example. Suppose that the input volume is a numpy array <code class="docutils literal notranslate"><span class="pre">X</span></code>. Then:</p>
<ul class="simple">
<li><p>A depth column (or a fibre) at position <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> would be the activations <code class="docutils literal notranslate"><span class="pre">X[x,y,:]</span></code>.</p></li>
<li><p>A depth slice, or equivalently an activation map at depth <code class="docutils literal notranslate"><span class="pre">d</span></code> would be the activations <code class="docutils literal notranslate"><span class="pre">X[:,:,d]</span></code>.</p></li>
</ul>
<p><em>Conv Layer Example</em> Suppose that the input volume <code class="docutils literal notranslate"><span class="pre">X</span></code> has shape <code class="docutils literal notranslate"><span class="pre">X.shape:</span> <span class="pre">(11,11,4)</span></code>. Suppose further that we use no zero padding (<span class="math notranslate nohighlight">\(P=0\)</span>
), that the filter size is <span class="math notranslate nohighlight">\(F=5\)</span>, and that the stride is <span class="math notranslate nohighlight">\(S=2\)</span>. The output volume would therefore have spatial size <span class="math notranslate nohighlight">\((11-5)/2+1 = 4\)</span>, giving a volume with width and height of <span class="math notranslate nohighlight">\(4\)</span>. The activation map in the output volume (call it <code class="docutils literal notranslate"><span class="pre">V</span></code>), would then look as follows (only some of the elements are computed in this example):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>V[0,0,0] = np.sum(X[:5,:5,:] * W0) + b0
V[1,0,0] = np.sum(X[2:7,:5,:] * W0) + b0
V[2,0,0] = np.sum(X[4:9,:5,:] * W0) + b0
V[3,0,0] = np.sum(X[6:11,:5,:] * W0) + b0
</pre></div>
</div>
<p>Remember that in numpy, the operation <span class="math notranslate nohighlight">\(*\)</span> above denotes elementwise multiplication between the arrays. Notice also that the weight vector <code class="docutils literal notranslate"><span class="pre">W0</span></code> is the weight vector of that neuron and <code class="docutils literal notranslate"><span class="pre">b0</span></code> is the bias. Here, <code class="docutils literal notranslate"><span class="pre">W0</span></code> is assumed to be of shape <code class="docutils literal notranslate"><span class="pre">W0.shape:</span> <span class="pre">(5,5,4)</span></code>, since the filter size is <span class="math notranslate nohighlight">\(5\)</span> and the depth of the input volume is <span class="math notranslate nohighlight">\(4\)</span>. Notice that at each point, we are computing the dot product as seen before in ordinary neural networks. Also, we see that we are using the same weight and bias (due to parameter sharing), and where the dimensions along the width are increasing in steps of <span class="math notranslate nohighlight">\(2\)</span> (i.e. the stride). To construct a second activation map in the output volume, we would have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>V[0,0,1] = np.sum(X[:5,:5,:] * W1) + b1
V[1,0,1] = np.sum(X[2:7,:5,:] * W1) + b1
V[2,0,1] = np.sum(X[4:9,:5,:] * W1) + b1
V[3,0,1] = np.sum(X[6:11,:5,:] * W1) + b1
V[0,1,1] = np.sum(X[:5,2:7,:] * W1) + b1 (example of going along y)
V[2,3,1] = np.sum(X[4:9,6:11,:] * W1) + b1 (or along both)
</pre></div>
</div>
<p>where we see that we are indexing into the second depth dimension in <code class="docutils literal notranslate"><span class="pre">V</span></code> (at index <span class="math notranslate nohighlight">\(1\)</span>) because we are computing the second activation map, and that a different set of parameters (<code class="docutils literal notranslate"><span class="pre">W1</span></code>) is now used. In the example above, we are for brevity leaving out some of the other operations the Conv Layer would perform to fill the other parts of the output array <code class="docutils literal notranslate"><span class="pre">V</span></code>. Additionally, recall that these activation maps are often followed elementwise through an activation function such as ReLU, but this is not shown here.</p>
<p><strong>Summary:</strong> To summarize, the Conv Layer:</p>
<ul class="simple">
<li><p>Accepts a volume of size <code class="docutils literal notranslate"><span class="pre">W1*H1*D1</span></code></p></li>
<li><p>Requires four hyperparameters:</p>
<ul>
<li><p>Number of filters <code class="docutils literal notranslate"><span class="pre">K</span></code></p></li>
<li><p>their spatial extent <code class="docutils literal notranslate"><span class="pre">F</span></code></p></li>
<li><p>the stride <code class="docutils literal notranslate"><span class="pre">S</span></code></p></li>
<li><p>the amount of zero padding <code class="docutils literal notranslate"><span class="pre">P</span></code></p></li>
</ul>
</li>
<li><p>Produces a volume of size <code class="docutils literal notranslate"><span class="pre">W2×H2×D2</span></code>, where:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">W2=(W1−F+2P)/S+1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H2=(H1−F+2P)/S+1</span></code>(i.e. width and height are computed equally by symmetry)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">D2=K</span></code></p></li>
</ul>
</li>
<li><p>With parameter sharing, it introduces <code class="docutils literal notranslate"><span class="pre">F⋅F⋅D1</span></code> weights per filter, for a total of <code class="docutils literal notranslate"><span class="pre">(F⋅F⋅D1)⋅K</span></code> weights and K-biases.</p></li>
<li><p>In the output volume, the <code class="docutils literal notranslate"><span class="pre">d</span></code>-th depth slice (of size <code class="docutils literal notranslate"><span class="pre">W2×H2</span></code>) is the result of performing a valid convolution of the <code class="docutils literal notranslate"><span class="pre">d</span></code>-th filter over the input volume with a stride of <code class="docutils literal notranslate"><span class="pre">S</span></code>, and then offset by <code class="docutils literal notranslate"><span class="pre">d</span></code>-th bias.</p></li>
</ul>
<p>A common setting of the hyperparameters is <code class="docutils literal notranslate"><span class="pre">F=3,S=1,P=1</span></code>. However, there are common conventions and rules of thumb that motivate these hyperparameters. See the ConvNet architectures section below.</p>
<p><strong>Convolution Demo:</strong> Below is a running demo of a CONV layer. Since 3D volumes are hard to visualize, all the volumes (the input volume (in blue), the weight volumes (in red), the output volume (in green)) are visualized with each depth slice stacked in rows. The input volume is of size <code class="docutils literal notranslate"><span class="pre">W1=5,H1=5,D1=3</span></code>, and the CONV layer parameters are <code class="docutils literal notranslate"><span class="pre">K=2,F=3,S=2,P=1</span></code>. That is, we have two filters of size <span class="math notranslate nohighlight">\(3×3\)</span>, and they are applied with a stride of <code class="docutils literal notranslate"><span class="pre">2</span></code>. Therefore, the output volume size has spatial size <span class="math notranslate nohighlight">\((5 - 3 + 2)/2 + 1 = 3\)</span>. Moreover, notice that a padding of <code class="docutils literal notranslate"><span class="pre">P=1</span></code> is applied to the input volume, making the outer border of the input volume zero. The visualization below iterates over the output activations (green), and shows that each element is computed by elementwise multiplying the highlighted input (blue) with the filter (red), summing it up, and then offsetting the result by the bias.</p>
<div class="figure align-default" id="image7">
<a class="reference internal image-reference" href="../../../_images/image7.gif"><img alt="../../../_images/image7.gif" src="../../../_images/image7.gif" style="height: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 37 </span><span class="caption-text">Running demo of a CONV layer</span><a class="headerlink" href="#image7" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Implementation as Matrix Multiplication:</strong> Note that the convolution operation essentially performs dot products between the filters and local regions of the input. A common implementation pattern of the CONV layer is to take advantage of this fact and formulate the forward pass of a convolutional layer as one big matrix multiply as follows:</p>
<ul class="simple">
<li><p>The local regions in the input image are stretched out into columns in an operation commonly called <strong>im2col</strong>. For example, if the input is <span class="math notranslate nohighlight">\([227*227*3]\)</span> and it is to be convolved with <span class="math notranslate nohighlight">\(11*11*3\)</span> filters at stride <span class="math notranslate nohighlight">\(4\)</span>, then we would take <span class="math notranslate nohighlight">\([11*11*3]\)</span> blocks of pixels in the input and stretch each block into a column vector of size <span class="math notranslate nohighlight">\(11*11*3 = 363\)</span>. Iterating this process in the input at stride of <span class="math notranslate nohighlight">\(4\)</span> gives <span class="math notranslate nohighlight">\((227-11)/4+1 = 55\)</span> locations along both width and height, leading to an output matrix <code class="docutils literal notranslate"><span class="pre">X_col</span></code> of <strong>im2col</strong> of size <span class="math notranslate nohighlight">\([363 * 3025]\)</span>, where every column is a stretched out receptive field and there are <span class="math notranslate nohighlight">\(55*55 = 3025\)</span> of them in total. Note that since the receptive fields overlap, every number in the input volume may be duplicated in multiple distinct columns.</p></li>
<li><p>The weights of the CONV layer are similarly stretched out into rows. For example, if there are <span class="math notranslate nohighlight">\(96\)</span> filters of size <span class="math notranslate nohighlight">\([11*11*3]\)</span> this would give a matrix W_row of size <span class="math notranslate nohighlight">\([96 * 363]\)</span>.</p></li>
<li><p>The result of a convolution is now equivalent to performing one large matrix multiply <code class="docutils literal notranslate"><span class="pre">np.dot(W_row,</span> <span class="pre">X_col)</span></code>, which evaluates the dot product between every filter and every receptive field location. In our example, the output of this operation would be <span class="math notranslate nohighlight">\([96 * 3025]\)</span>, giving the output of the dot product of each filter at each location.</p></li>
<li><p>The result must finally be reshaped back to its proper output dimension <span class="math notranslate nohighlight">\([55*55*96]\)</span>.</p></li>
</ul>
<p>This approach has the downside that it can use a lot of memory, since some values in the input volume are replicated multiple times in <code class="docutils literal notranslate"><span class="pre">X_col</span></code>. However, the benefit is that there are many very efficient implementations of Matrix Multiplication that we can take advantage of (for example, in the commonly used <a class="reference external" href="http://www.netlib.org/blas/">BLAS</a> API). Moreover, the same <strong>im2col</strong> idea can be reused to perform the pooling operation, which we discuss next.</p>
<p><strong>Backpropagation:</strong> The backward pass for a convolution operation (for both the data and the weights) is also a convolution (but with spatially-flipped filters). This is easy to derive in the 1-dimensional case with a toy example (not expanded on for now).</p>
<p><strong>1x1 convolution:</strong> As an aside, several papers use <span class="math notranslate nohighlight">\(1*1\)</span> convolutions, as first investigated by <a class="reference external" href="http://arxiv.org/abs/1312.4400">Network in Network</a>. Some people are at first confused to see <span class="math notranslate nohighlight">\(1*1\)</span> convolutions especially when they come from signal processing background. Normally signals are 2-dimensional so <span class="math notranslate nohighlight">\(1*1\)</span> convolutions do not make sense (it’s just pointwise scaling). However, in ConvNets this is not the case because one must remember that we operate over 3-dimensional volumes, and that the filters always extend through the full depth of the input volume. For example, if the input is <span class="math notranslate nohighlight">\([32*32*3]\)</span> then doing <span class="math notranslate nohighlight">\(1*1\)</span> convolutions would effectively be doing 3-dimensional dot products (since the input depth is 3 channels).</p>
<p><strong>Dilated convolutions:</strong> A recent development (e.g. see paper by <a class="reference external" href="https://arxiv.org/abs/1511.07122">Fisher Yu and Vladlen Koltun</a>) is to introduce one more hyperparameter to the CONV layer called the dilation. So far we’ve only discussed CONV filters that are contiguous. However, it’s possible to have filters that have spaces between each cell, called dilation. As an example, in one dimension a filter <code class="docutils literal notranslate"><span class="pre">w</span></code> of size <code class="docutils literal notranslate"><span class="pre">3</span></code> would compute over input <code class="docutils literal notranslate"><span class="pre">x</span></code> the following: <code class="docutils literal notranslate"><span class="pre">w[0]*x[0]</span> <span class="pre">+</span> <span class="pre">w[1]*x[1]</span> <span class="pre">+</span> <span class="pre">w[2]*x[2]</span></code>. This is dilation of <code class="docutils literal notranslate"><span class="pre">0</span></code>. For dilation <code class="docutils literal notranslate"><span class="pre">1</span></code> the filter would instead compute <code class="docutils literal notranslate"><span class="pre">w[0]*x[0]</span> <span class="pre">+</span> <span class="pre">w[1]*x[2]</span> <span class="pre">+</span> <span class="pre">w[2]*x[4]</span></code>; In other words there is a gap of 1 between the applications. This can be very useful in some settings to use in conjunction with 0-dilated filters because it allows you to merge spatial information across the inputs much more agressively with fewer layers. For example, if you stack two <span class="math notranslate nohighlight">\(3*3\)</span> CONV layers on top of each other then you can convince yourself that the neurons on the 2nd layer are a function of a <span class="math notranslate nohighlight">\(5*5\)</span> patch of the input (we would say that the effective receptive field of these neurons is <span class="math notranslate nohighlight">\(5*5\)</span>). If we use dilated convolutions then this effective receptive field would grow much quicker.</p>
</div>
<div class="section" id="pooling-layer">
<h3>Pooling Layer<a class="headerlink" href="#pooling-layer" title="Permalink to this headline">¶</a></h3>
<p>It is common to periodically insert a Pooling layer in-between successive Conv layers in a ConvNet architecture. Its function is to progressively reduce the spatial size of the representation to reduce the amount of parameters and computation in the network, and hence to also control overfitting. The Pooling Layer operates independently on every depth slice of the input and resizes it spatially, using the MAX operation. The most common form is a pooling layer with filters of size <span class="math notranslate nohighlight">\(2*2\)</span> applied with a stride of <span class="math notranslate nohighlight">\(2\)</span> downsamples every depth slice in the input by <span class="math notranslate nohighlight">\(2\)</span> along both width and height, discarding <span class="math notranslate nohighlight">\(75%\)</span> of the activations. Every MAX operation would in this case be taking a max over <span class="math notranslate nohighlight">\(4\)</span> numbers (little <span class="math notranslate nohighlight">\(2*2\)</span> region in some depth slice). The depth dimension remains unchanged. More generally, the pooling layer:</p>
<ul class="simple">
<li><p>Accepts a volume of size <span class="math notranslate nohighlight">\(W1×H1×D1\)</span></p></li>
<li><p>Requires two hyperparameters:</p>
<ul>
<li><p>their spatial extent F</p></li>
<li><p>the stride S</p></li>
</ul>
</li>
<li><p>Produces a volume of size <span class="math notranslate nohighlight">\(W2×H2×D2\)</span>, where:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(W2=(W1−F)/S+1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(H2=(H1−F)/S+1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(D2=D1\)</span></p></li>
</ul>
</li>
<li><p>Introduces zero parameters since it computes a fixed function of the input</p></li>
<li><p>For Pooling layers, it is not common to pad the input using zero-padding</p></li>
</ul>
<p>It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with <span class="math notranslate nohighlight">\(F=3,S=2\)</span>
(also called overlapping pooling), and more commonly <span class="math notranslate nohighlight">\(F=2,S=2\)</span>. Pooling sizes with larger receptive fields are too destructive.</p>
<p><strong>General pooling:</strong> In addition to max pooling, the pooling units can also perform other functions, such as average pooling or even L2-norm pooling. Average pooling was often used historically but has recently fallen out of favor compared to the max pooling operation, which has been shown to work better in practice.</p>
<div class="figure align-default" id="image8">
<a class="reference internal image-reference" href="../../../_images/image8.png"><img alt="../../../_images/image8.png" src="../../../_images/image8.png" style="height: 250px;" /></a>
<p class="caption"><span class="caption-number">Fig. 38 </span><span class="caption-text">Pooling layer downsamples the volume spatially, independently in each depth slice of the input volume. Left: In this example, the input volume of size [224x224x64] is pooled with filter size 2, stride 2 into output volume of size [112x112x64]. Notice that the volume depth is preserved. Right: The most common downsampling operation is max, giving rise to max pooling, here shown with a stride of 2. That is, each max is taken over 4 numbers (little 2x2 square).</span><a class="headerlink" href="#image8" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Backpropagation:</strong> Recall that the backward pass for a max(x, y) operation has a simple interpretation as only routing the gradient to the input that had the highest value in the forward pass. Hence, during the forward pass of a pooling layer it is common to keep track of the index of the max activation (sometimes also called the switches) so that gradient routing is efficient during backpropagation.</p>
<p><strong>Getting rid of pooling:</strong> Many people dislike the pooling operation and think that we can get away without it. For example, <a class="reference external" href="http://arxiv.org/abs/1412.6806">Striving for Simplicity: The All Convolutional Net</a> proposes to discard the pooling layer in favor of architecture that only consists of repeated CONV layers. To reduce the size of the representation they suggest using larger stride in CONV layer once in a while. Discarding pooling layers has also been found to be important in training good generative models, such as variational autoencoders (VAEs) or generative adversarial networks (GANs). It seems likely that future architectures will feature very few to no pooling layers.</p>
</div>
<div class="section" id="normalization-layer">
<h3>Normalization Layer<a class="headerlink" href="#normalization-layer" title="Permalink to this headline">¶</a></h3>
<p>Many types of normalization layers have been proposed for use in ConvNet architectures, sometimes with the intentions of implementing inhibition schemes observed in the biological brain. However, these layers have since fallen out of favor because in practice their contribution has been shown to be minimal, if any. For various types of normalizations, see the discussion in <a class="reference external" href="http://code.google.com/p/cuda-convnet/wiki/LayerParams#Local_response_normalization_layer_(same_map)">Alex Krizhevsky’s cuda-convnet library API</a>.</p>
</div>
<div class="section" id="fully-connected-layer">
<h3>Fully-connected layer<a class="headerlink" href="#fully-connected-layer" title="Permalink to this headline">¶</a></h3>
<p>Neurons in a fully connected layer have full connections to all activations in the previous layer, as seen in regular Neural Networks. Their activations can hence be computed with a matrix multiplication followed by a bias offset. See the Neural Network section of the notes for more information.</p>
</div>
<div class="section" id="converting-fc-layers-to-conv-layers">
<h3>Converting FC layers to CONV layers<a class="headerlink" href="#converting-fc-layers-to-conv-layers" title="Permalink to this headline">¶</a></h3>
<p>It is worth noting that the only difference between FC and CONV layers is that the neurons in the CONV layer are connected only to a local region in the input, and that many of the neurons in a CONV volume share parameters. However, the neurons in both layers still compute dot products, so their functional form is identical. Therefore, it turns out that it’s possible to convert between FC and CONV layers:</p>
<ul class="simple">
<li><p>For any CONV layer there is an FC layer that implements the same forward function. The weight matrix would be a large matrix that is mostly zero except for at certain blocks (due to local connectivity) where the weights in many of the blocks are equal (due to parameter sharing).</p></li>
<li><p>Conversely, any FC layer can be converted to a CONV layer. For example, an FC layer with <span class="math notranslate nohighlight">\(K=4096\)</span> that is looking at some input volume of size <span class="math notranslate nohighlight">\(7*7*512\)</span> can be equivalently expressed as a CONV layer with <span class="math notranslate nohighlight">\(F=7,P=0,S=1,K=4096\)</span>. In other words, we are setting the filter size to be exactly the size of the input volume, and hence the output will simply be <span class="math notranslate nohighlight">\(1*1*4096\)</span> since only a single depth column “fits” across the input volume, giving identical result as the initial FC layer.</p></li>
</ul>
<p><strong>FC-&gt;CONV conversion:</strong> Of these two conversions, the ability to convert an FC layer to a CONV layer is particularly useful in practice. Consider a ConvNet architecture that takes a <span class="math notranslate nohighlight">\(224*224*3\)</span> image, and then uses a series of CONV layers and POOL layers to reduce the image to an activations volume of size <span class="math notranslate nohighlight">\(7*7*512\)</span> (in an AlexNet architecture that we’ll see later, this is done by use of <span class="math notranslate nohighlight">\(5\)</span> pooling layers that downsample the input spatially by a factor of two each time, making the final spatial size <span class="math notranslate nohighlight">\(224/2/2/2/2/2 = 7\)</span>). From there, an AlexNet uses two FC layers of size <span class="math notranslate nohighlight">\(4096\)</span> and finally the last FC layers with <span class="math notranslate nohighlight">\(1000\)</span> neurons that compute the class scores. We can convert each of these three FC layers to CONV layers as described above:</p>
<ul class="simple">
<li><p>Replace the first FC layer that looks at <span class="math notranslate nohighlight">\([7*7*512]\)</span> volume with a CONV layer that uses filter size <span class="math notranslate nohighlight">\(F=7\)</span>, giving output volume <span class="math notranslate nohighlight">\([1*1*4096]\)</span>.</p></li>
<li><p>Replace the second FC layer with a CONV layer that uses filter size <span class="math notranslate nohighlight">\(F=1\)</span>, giving output volume <span class="math notranslate nohighlight">\([1*1*4096]\)</span></p></li>
<li><p>Replace the last FC layer similarly, with <span class="math notranslate nohighlight">\(F=1\)</span>, giving final output <span class="math notranslate nohighlight">\([1*1*1000]\)</span></p></li>
</ul>
<p>Each of these conversions could in practice involve manipulating (e.g. reshaping) the weight matrix <span class="math notranslate nohighlight">\(W\)</span> in each FC layer into CONV layer filters. It turns out that this conversion allows us to “slide” the original ConvNet very efficiently across many spatial positions in a larger image, in a single forward pass.</p>
<p>For example, if <span class="math notranslate nohighlight">\(224*224\)</span> image gives a volume of size <span class="math notranslate nohighlight">\([7*7*512]\)</span> - i.e. a reduction by <span class="math notranslate nohighlight">\(32\)</span>, then forwarding an image of size <span class="math notranslate nohighlight">\(384*384\)</span> through the converted architecture would give the equivalent volume in size <span class="math notranslate nohighlight">\([12*12*512]\)</span>, since <span class="math notranslate nohighlight">\(384/32 = 12\)</span>. Following through with the next <span class="math notranslate nohighlight">\(3\)</span> CONV layers that we just converted from FC layers would now give the final volume of size <span class="math notranslate nohighlight">\([6*6*1000]\)</span>, since <span class="math notranslate nohighlight">\((12 - 7)/1 + 1 = 6\)</span>. Note that instead of a single vector of class scores of size <span class="math notranslate nohighlight">\([1*1*1000]\)</span>, we’re now getting an entire <span class="math notranslate nohighlight">\(6*6\)</span> array of class scores across the <span class="math notranslate nohighlight">\(384*384\)</span> image.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Evaluating the original ConvNet (with FC layers) independently across 224x224 crops of the 384x384 image in strides of 32 pixels gives an identical result to forwarding the converted ConvNet one time.</p>
</div>
<p>Naturally, forwarding the converted ConvNet a single time is much more efficient than iterating the original ConvNet over all those <span class="math notranslate nohighlight">\(36\)</span> locations, since the <span class="math notranslate nohighlight">\(36\)</span> evaluations share computation. This trick is often used in practice to get better performance, where for example, it is common to resize an image to make it bigger, use a converted ConvNet to evaluate the class scores at many spatial positions and then average the class scores.</p>
<p>Lastly, what if we wanted to efficiently apply the original ConvNet over the image but at a stride smaller than <span class="math notranslate nohighlight">\(32\)</span> pixels? We could achieve this with multiple forward passes. For example, note that if we wanted to use a stride of <span class="math notranslate nohighlight">\(16\)</span> pixels we could do so by combining the volumes received by forwarding the converted ConvNet twice: First over the original image and second over the image but with the image shifted spatially by <span class="math notranslate nohighlight">\(16\)</span> pixels along both width and height.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An <a class="reference external" href="https://github.com/BVLC/caffe/blob/master/examples/net_surgery.ipynb">IPython Notebook on Net Surgery</a> shows how to perform the conversion in practice, in code (using Caffe)</p>
</div>
</div>
</div>
<div class="section" id="convnet-architectures">
<h2>ConvNet Architectures<a class="headerlink" href="#convnet-architectures" title="Permalink to this headline">¶</a></h2>
<p>We have seen that Convolutional Networks are commonly made up of only three layer types: CONV, POOL (we assume Max pool unless stated otherwise) and FC (short for fully-connected). We will also explicitly write the RELU activation function as a layer, which applies elementwise non-linearity. In this section we discuss how these are commonly stacked together to form entire ConvNets.</p>
<div class="section" id="layer-patterns">
<h3>Layer Patterns<a class="headerlink" href="#layer-patterns" title="Permalink to this headline">¶</a></h3>
<p>The most common form of a ConvNet architecture stacks a few CONV-RELU layers, follows them with POOL layers, and repeats this pattern until the image has been merged spatially to a small size. At some point, it is common to transition to fully-connected layers. The last fully-connected layer holds the output, such as the class scores. In other words, the most common ConvNet architecture follows the pattern:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INPUT -&gt; [[CONV -&gt; RELU]*N -&gt; POOL?]*M -&gt; [FC -&gt; RELU]*K -&gt; FC
</pre></div>
</div>
<p>where the <span class="math notranslate nohighlight">\(*\)</span> indicates repetition, and the POOL? indicates an optional pooling layer. Moreover, <span class="math notranslate nohighlight">\(N &gt;= 0\)</span> (and usually <span class="math notranslate nohighlight">\(N &lt;= 3\)</span>), <span class="math notranslate nohighlight">\(M &gt;= 0, K &gt;= 0\)</span> (and usually <span class="math notranslate nohighlight">\(K &lt; 3\)</span>). For example, here are some common ConvNet architectures you may see that follow this pattern:</p>
<ul class="simple">
<li><p>INPUT -&gt; FC, implements a linear classifier. Here N = M = K = 0.</p></li>
<li><p>INPUT -&gt; CONV -&gt; RELU -&gt; FC</p></li>
<li><p>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC. Here we see that there is a single CONV layer between every POOL layer.</p></li>
<li><p>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC Here we see two CONV layers stacked before every POOL layer. This is generally a good idea for larger and deeper networks, because multiple stacked CONV layers can develop more complex features of the input volume before the destructive pooling operation.</p></li>
</ul>
<p>Prefer a stack of small filter CONV to one large receptive field CONV layer. Suppose that you stack three <span class="math notranslate nohighlight">\(3*3\)</span> CONV layers on top of each other (with non-linearities in between, of course). In this arrangement, each neuron on the first CONV layer has a <span class="math notranslate nohighlight">\(3*3\)</span> view of the input volume. A neuron on the second CONV layer has a <span class="math notranslate nohighlight">\(3*3\)</span> view of the first CONV layer, and hence by extension a <span class="math notranslate nohighlight">\(5*5\)</span> view of the input volume. Similarly, a neuron on the third CONV layer has a <span class="math notranslate nohighlight">\(3*3\)</span> view of the 2nd CONV layer, and hence a <span class="math notranslate nohighlight">\(7*7\)</span> view of the input volume. Suppose that instead of these three layers of <span class="math notranslate nohighlight">\(3*3\)</span> CONV, we only wanted to use a single CONV layer with <span class="math notranslate nohighlight">\(7*7\)</span> receptive fields. These neurons would have a receptive field size of the input volume that is identical in spatial extent (<span class="math notranslate nohighlight">\(7*7\)</span>), but with several disadvantages. First, the neurons would be computing a linear function over the input, while the three stacks of CONV layers contain non-linearities that make their features more expressive. Second, if we suppose that all the volumes have C channels, then it can be seen that the single <span class="math notranslate nohighlight">\(7*7\)</span> CONV layer would contain <span class="math notranslate nohighlight">\(C*(7*7*C)=49C^2\)</span> parameters, while the three <span class="math notranslate nohighlight">\(3*3\)</span> CONV layers would only contain <span class="math notranslate nohighlight">\(3*(C*(3*3*C))=27C^2\)</span> parameters. Intuitively, stacking CONV layers with tiny filters as opposed to having one CONV layer with big filters allows us to express more powerful features of the input, and with fewer parameters. As a practical disadvantage, we might need more memory to hold all the intermediate CONV layer results if we plan to do backpropagation.</p>
<p><strong>Recent departures:</strong> It should be noted that the conventional paradigm of a linear list of layers has recently been challenged, in Google’s Inception architectures and also in current (state of the art) Residual Networks from Microsoft Research Asia. Both of these (see details below in case studies section) feature more intricate and different connectivity structures.</p>
<p><strong>In practice:</strong> use whatever works best on ImageNet. If you’re feeling a bit of a fatigue in thinking about the architectural decisions, you’ll be pleased to know that in 90% or more of applications you should not have to worry about these. I like to summarize this point as “don’t be a hero”: Instead of rolling your own architecture for a problem, you should look at whatever architecture currently works best on ImageNet, download a pretrained model and finetune it on your data. You should rarely ever have to train a ConvNet from scratch or design one from scratch. I also made this point at the <a class="reference external" href="https://www.youtube.com/watch?v=u6aEYuemt0M">Deep Learning school</a>.</p>
</div>
<div class="section" id="layer-sizing-patterns">
<h3>Layer Sizing Patterns<a class="headerlink" href="#layer-sizing-patterns" title="Permalink to this headline">¶</a></h3>
<p>Until now we’ve omitted mentions of common hyperparameters used in each of the layers in a ConvNet. We will first state the common rules of thumb for sizing the architectures and then follow the rules with a discussion of the notation:</p>
<ul class="simple">
<li><p>The input layer (that contains the image) should be divisible by <span class="math notranslate nohighlight">\(2\)</span> many times. Common numbers include <span class="math notranslate nohighlight">\(32\)</span> (e.g. CIFAR-10), <span class="math notranslate nohighlight">\(64\)</span>, <span class="math notranslate nohighlight">\(96\)</span> (e.g. STL-10), or <span class="math notranslate nohighlight">\(224\)</span> (e.g. common ImageNet ConvNets), <span class="math notranslate nohighlight">\(384\)</span>, and <span class="math notranslate nohighlight">\(512\)</span>.</p></li>
<li><p>The conv layers should be using small filters (e.g. <span class="math notranslate nohighlight">\(3*3\)</span> or at most <span class="math notranslate nohighlight">\(5*5\)</span>), using a stride of <span class="math notranslate nohighlight">\(S=1\)</span>, and crucially, padding the input volume with zeros in such way that the conv layer does not alter the spatial dimensions of the input. That is, when <span class="math notranslate nohighlight">\(F=3\)</span>, then using <span class="math notranslate nohighlight">\(P=1\)</span> will retain the original size of the input. When <span class="math notranslate nohighlight">\(F=5, P=2\)</span>. For a general F, it can be seen that <span class="math notranslate nohighlight">\(P=(F−1)/2\)</span> preserves the input size. If you must use bigger filter sizes (such as <span class="math notranslate nohighlight">\(7*7\)</span> or so), it is only common to see this on the very first conv layer that is looking at the input image.</p></li>
<li><p>The pool layers are in charge of downsampling the spatial dimensions of the input. The most common setting is to use max-pooling with <span class="math notranslate nohighlight">\(2*2\)</span> receptive fields (i.e. <span class="math notranslate nohighlight">\(F=2\)</span>), and with a stride of <span class="math notranslate nohighlight">\(2\)</span> (i.e. <span class="math notranslate nohighlight">\(S=2\)</span>). Note that this discards exactly <span class="math notranslate nohighlight">\(75%\)</span> of the activations in an input volume (due to downsampling by <span class="math notranslate nohighlight">\(2\)</span> in both width and height). Another slightly less common setting is to use <span class="math notranslate nohighlight">\(3*3\)</span> receptive fields with a stride of <span class="math notranslate nohighlight">\(2\)</span>, but this makes. It is very uncommon to see receptive field sizes for max pooling that are larger than <span class="math notranslate nohighlight">\(3\)</span> because the pooling is then too lossy and aggressive. This usually leads to worse performance.</p></li>
</ul>
<p><strong>Reducing sizing headaches:</strong> The scheme presented above is pleasing because all the CONV layers preserve the spatial size of their input, while the POOL layers alone are in charge of down-sampling the volumes spatially. In an alternative scheme where we use strides greater than 1 or don’t zero-pad the input in CONV layers, we would have to very carefully keep track of the input volumes throughout the CNN architecture and make sure that all strides and filters “work out”, and that the ConvNet architecture is nicely and symmetrically wired.</p>
<p><strong>Why use stride of 1 in CONV?</strong> Smaller strides work better in practice. Additionally, as already mentioned stride <span class="math notranslate nohighlight">\(1\)</span> allows us to leave all spatial down-sampling to the POOL layers, with the CONV layers only transforming the input volume depth-wise.</p>
<p><strong>Why use padding?</strong> In addition to the aforementioned benefit of keeping the spatial sizes constant after CONV, doing this actually improves performance. If the CONV layers were to not zero-pad the inputs and only perform valid convolutions, then the size of the volumes would reduce by a small amount after each CONV, and the information at the borders would be “washed away” too quickly.</p>
<p><strong>Compromising based on memory constraints:</strong> In some cases (especially early in the ConvNet architectures), the amount of memory can build up very quickly with the rules of thumb presented above. For example, filtering a <span class="math notranslate nohighlight">\(224*224*3\)</span> image with three <span class="math notranslate nohighlight">\(3*3\)</span> CONV layers with <span class="math notranslate nohighlight">\(64\)</span> filters each and padding <span class="math notranslate nohighlight">\(1\)</span> would create three activation volumes of size <span class="math notranslate nohighlight">\([224*224*64]\)</span>. This amounts to a total of about <span class="math notranslate nohighlight">\(10\)</span> million activations, or 72MB of memory (per image, for both activations and gradients). Since GPUs are often bottlenecked by memory, it may be necessary to compromise. In practice, people prefer to make the compromise at only the first CONV layer of the network. For example, one compromise might be to use a first CONV layer with filter sizes of <span class="math notranslate nohighlight">\(7*7\)</span> and stride of <span class="math notranslate nohighlight">\(2\)</span> (as seen in a ZF net). As another example, an AlexNet uses filter sizes of <span class="math notranslate nohighlight">\(11*11\)</span> and stride of <span class="math notranslate nohighlight">\(4\)</span>.</p>
</div>
</div>
<div class="section" id="case-studies">
<h2>Case studies<a class="headerlink" href="#case-studies" title="Permalink to this headline">¶</a></h2>
<p>There are several architectures in the field of Convolutional Networks that have a name. The most common are:</p>
<ul class="simple">
<li><p><strong><a class="reference external" href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">LeNet</a>:</strong> The first successful applications of Convolutional Networks were developed by Yann LeCun in 1990’s. Of these, the best known is the LeNet architecture that was used to read zip codes, digits, etc.</p></li>
<li><p><strong><a class="reference external" href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">AlexNet</a>:</strong> The first work that popularized Convolutional Networks in Computer Vision was the AlexNet, developed by Alex Krizhevsky, Ilya Sutskever and Geoff Hinton. The AlexNet was submitted to the ImageNet ILSVRC challenge in 2012 and significantly outperformed the second runner-up (top 5 error of 16% compared to runner-up with 26% error). The Network had a very similar architecture to LeNet, but was deeper, bigger, and featured Convolutional Layers stacked on top of each other (previously it was common to only have a single CONV layer always immediately followed by a POOL layer).</p></li>
<li><p><strong><a class="reference external" href="http://arxiv.org/abs/1311.2901">ZF Net</a>:</strong> The ILSVRC 2013 winner was a Convolutional Network from Matthew Zeiler and Rob Fergus. It became known as the ZFNet (short for Zeiler &amp; Fergus Net). It was an improvement on AlexNet by tweaking the architecture hyperparameters, in particular by expanding the size of the middle convolutional layers and making the stride and filter size on the first layer smaller.</p></li>
<li><p><strong><a class="reference external" href="http://arxiv.org/abs/1409.4842">GoogLeNet</a>:</strong> The ILSVRC 2014 winner was a Convolutional Network from Szegedy et al. from Google. Its main contribution was the development of an Inception Module that dramatically reduced the number of parameters in the network (4M, compared to AlexNet with 60M). Additionally, this paper uses Average Pooling instead of Fully Connected layers at the top of the ConvNet, eliminating a large amount of parameters that do not seem to matter much. There are also several followup versions to the GoogLeNet, most recently <a class="reference external" href="http://arxiv.org/abs/1602.07261">Inception-v4</a>.</p></li>
<li><p><strong><a class="reference external" href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a>:</strong> The runner-up in ILSVRC 2014 was the network from Karen Simonyan and Andrew Zisserman that became known as the VGGNet. Its main contribution was in showing that the depth of the network is a critical component for good performance. Their final best network contains 16 CONV/FC layers and, appealingly, features an extremely homogeneous architecture that only performs 3x3 convolutions and 2x2 pooling from the beginning to the end. Their <a class="reference external" href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">pretrained model</a> is available for plug and play use in Caffe. A downside of the VGGNet is that it is more expensive to evaluate and uses a lot more memory and parameters (140M). Most of these parameters are in the first fully connected layer, and it was since found that these FC layers can be removed with no performance downgrade, significantly reducing the number of necessary parameters.</p></li>
<li><p><strong><a class="reference external" href="http://arxiv.org/abs/1512.03385">ResNet</a>:</strong> Residual Network developed by Kaiming He et al. was the winner of ILSVRC 2015. It features special skip connections and a heavy use of <a class="reference external" href="http://arxiv.org/abs/1502.03167">batch normalization</a>. The architecture is also missing fully connected layers at the end of the network. The reader is also referred to Kaiming’s presentation (<a class="reference external" href="https://www.youtube.com/watch?v=1PGLj-uKT1w">video</a>, <a class="reference external" href="http://research.microsoft.com/en-us/um/people/kahe/ilsvrc15/ilsvrc2015_deep_residual_learning_kaiminghe.pdf">slides</a>), and <a class="reference external" href="https://github.com/gcr/torch-residual-networks">some recent experiments</a> that reproduce these networks in Torch. ResNets are currently by far state of the art Convolutional Neural Network models and are the default choice for using ConvNets in practice (as of May 10, 2016). In particular, also see more recent developments that tweak the original architecture from <a class="reference external" href="https://arxiv.org/abs/1603.05027">Kaiming He et al. Identity Mappings in Deep Residual Networks</a> (published March 2016).</p></li>
</ul>
<p><strong>VGGNet in detail:</strong> Lets break down the VGGNet in more detail as a case study. The whole VGGNet is composed of CONV layers that perform <span class="math notranslate nohighlight">\(3*3\)</span> convolutions with stride <span class="math notranslate nohighlight">\(1\)</span> and pad <span class="math notranslate nohighlight">\(1\)</span>, and of POOL layers that perform <span class="math notranslate nohighlight">\(2*2\)</span> max pooling with stride <span class="math notranslate nohighlight">\(2\)</span> (and no padding). We can write out the size of the representation at each step of the processing and keep track of both the representation size and the total number of weights:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INPUT: [224x224x3]        memory:  224*224*3=150K   weights: 0
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*3)*64 = 1,728
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*64)*64 = 36,864
POOL2: [112x112x64]  memory:  112*112*64=800K   weights: 0
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*64)*128 = 73,728
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*128)*128 = 147,456
POOL2: [56x56x128]  memory:  56*56*128=400K   weights: 0
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*128)*256 = 294,912
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
POOL2: [28x28x256]  memory:  28*28*256=200K   weights: 0
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*256)*512 = 1,179,648
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
POOL2: [14x14x512]  memory:  14*14*512=100K   weights: 0
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
POOL2: [7x7x512]  memory:  7*7*512=25K  weights: 0
FC: [1x1x4096]  memory:  4096  weights: 7*7*512*4096 = 102,760,448
FC: [1x1x4096]  memory:  4096  weights: 4096*4096 = 16,777,216
FC: [1x1x1000]  memory:  1000 weights: 4096*1000 = 4,096,000

TOTAL memory: 24M * 4 bytes ~= 93MB / image (only forward! ~*2 for bwd)
TOTAL params: 138M parameters
</pre></div>
</div>
<p>As is common with Convolutional Networks, notice that most of the memory (and also compute time) is used in the early CONV layers, and that most of the parameters are in the last FC layers. In this particular case, the first FC layer contains 100M weights, out of a total of 140M.</p>
</div>
<div class="section" id="computational-considerations">
<h2>Computational Considerations<a class="headerlink" href="#computational-considerations" title="Permalink to this headline">¶</a></h2>
<p>The largest bottleneck to be aware of when constructing ConvNet architectures is the memory bottleneck. Many modern GPUs have a limit of 3/4/6GB memory, with the best GPUs having about 12GB of memory. There are three major sources of memory to keep track of:</p>
<ul class="simple">
<li><p><strong>From the intermediate volume sizes:</strong> These are the raw number of activations at every layer of the ConvNet, and also their gradients (of equal size). Usually, most of the activations are on the earlier layers of a ConvNet (i.e. first Conv Layers). These are kept around because they are needed for backpropagation, but a clever implementation that runs a ConvNet only at test time could in principle reduce this by a huge amount, by only storing the current activations at any layer and discarding the previous activations on layers below.</p></li>
<li><p><strong>From the parameter sizes:</strong> These are the numbers that hold the network parameters, their gradients during backpropagation, and commonly also a step cache if the optimization is using momentum, Adagrad, or RMSProp. Therefore, the memory to store the parameter vector alone must usually be multiplied by a factor of at least 3 or so.</p></li>
<li><p>Every ConvNet implementation has to maintain miscellaneous memory, such as the image data batches, perhaps their augmented versions, etc.</p></li>
</ul>
<p>Once you have a rough estimate of the total number of values (for activations, gradients, and misc), the number should be converted to size in GB. Take the number of values, multiply by 4 to get the raw number of bytes (since every floating point is 4 bytes, or maybe by 8 for double precision), and then divide by 1024 multiple times to get the amount of memory in KB, MB, and finally GB. If your network doesn’t fit, a common heuristic to “make it fit” is to decrease the batch size, since most of the memory is usually consumed by the activations.</p>
</div>
<div class="section" id="additional-resources">
<h2>Additional Resources<a class="headerlink" href="#additional-resources" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/soumith/convnet-benchmarks">Soumith benchmarks for CONV performance</a></p></li>
<li><p><a class="reference external" href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html">ConvNetJS CIFAR-10 demo</a> allows you to play with ConvNet architectures and see the results and computations in real time, in the browser</p></li>
<li><p><a class="reference external" href="https://poloclub.github.io/cnn-explainer/">Convolutional Neural Network (CNN) in your browser!</a></p></li>
<li><p><a class="reference external" href="http://caffe.berkeleyvision.org/">Caffe</a>, one of the popular ConvNet libraries.</p></li>
<li><p><a class="reference external" href="http://torch.ch/blog/2016/02/04/resnets.html">State of the art ResNets in Torch7</a></p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./contents\Deep Learning\Convolutional Neural Networks for Visual Recognition"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="../../Neural%20Network/Neural%20Networks%20as%20Universal%20Approximators.html" title="previous page">Neural Networks as Universal Approximators</a>
    <a class='right-next' id="next-link" href="Understanding%20and%20Visualizing%20Convolutional%20Neural%20Networks.html" title="next page">Understanding and Visualizing Convolutional Neural Networks</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Open Source Community<br/>
        
            &copy; Copyright MIT License.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../../_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>